---
title: "Mastering Atomic Vectors in R"
author: "Paramjot Singh"
date: 2018-03-11T19:14:27-05:00
draft: FALSE
tags: ["R"]
categories: ["Tools"]
output:
  blogdown::html_page:
    toc: true
    toc_depth: 3
---


<div id="TOC">
<ul>
<li><a href="#creating-our-first-atomic-vector">Creating Our First Atomic Vector</a></li>
<li><a href="#peeking-into-our-vector">Peeking into our Vector</a></li>
<li><a href="#objects-as-arguments-to-functions">Objects as Arguments to Functions</a></li>
<li><a href="#other-ways-of-creating-a-vector">Other Ways of Creating a Vector</a></li>
<li><a href="#vector-operations">Vector Operations</a></li>
<li><a href="#chaining-of-functions">Chaining of Functions</a></li>
<li><a href="#selecting-few-elements-of-a-vector-subsetting">Selecting Few Elements of a Vector (Subsetting)</a></li>
<li><a href="#more-uses-of-logical-subsetting">More Uses of Logical Subsetting</a></li>
<li><a href="#two-types-of-vectors">Two Types of Vectors</a></li>
<li><a href="#pick-elements-randomly">Pick Elements Randomly</a></li>
<li><a href="#some-special-values">Some Special Values</a></li>
<li><a href="#sequences-for-loops">Sequences for Loops</a></li>
<li><a href="#creating-an-empty-vector">Creating an empty vector</a></li>
<li><a href="#some-useful-vector-transformations">Some Useful Vector Transformations</a></li>
<li><a href="#comparing-two-vectors">Comparing Two Vectors</a></li>
<li><a href="#third-type-of-atomic-vector">Third Type of Atomic Vector</a></li>
<li><a href="#sorting-character-vectors-and-changing-case">Sorting Character Vectors and Changing Case</a></li>
<li><a href="#pattern-matching-in-character-vectors-using-regular-expressions">Pattern Matching in Character Vectors using Regular Expressions</a></li>
<li><a href="#stringr-tools">Stringr Tools</a></li>
<li><a href="#factors---an-augmented-vector-type">Factors - an Augmented Vector Type</a></li>
<li><a href="#summary">Summary</a></li>
</ul>
</div>

<p>Atomic vectors in R are the fundamental data structures on which other more complex data structures are built. When we are comfortable manipulating atomic vectors, it is easier and more natural to work with higher level structures like lists, data frames and tibbles. So here I focus the discussion only on atomic vectors. This will also allow us to discuss and learn fundamental programming concepts without getting distracted by ‘variety’ of data structures. We will start with very simple vector and build upon our knowledge as we learn new things going forward.</p>
<blockquote>
<p>Everything that exists in R is an <code>object</code> and anything that happens is a <code>function</code> call.</p>
</blockquote>
<div id="creating-our-first-atomic-vector" class="section level3">
<h3>Creating Our First Atomic Vector</h3>
<p>We are going to create and manipulate vectors using existing functions and the resulting objects will be atomic vectors. To create the objects (atomic vectors in our case), we will use an assignment operator (&lt;-). So we create our first object (<em>num_one</em>), and assign it a value of 3:</p>
<pre class="r white"><code>num_one &lt;- 3</code></pre>
<p>Atomic vectors can only have one ‘type’ of data, and we start with <code>numeric</code> data type since this will be the most common one for our data analysis work. Our simple vector contains only one element (commonly called a scalar), but in all respects, it is a vector in R. <code>Expressions</code> on the right side are evaluated first and then assigned to the object name on the left. Let’s look at an expression evaluation:</p>
<pre class="r white"><code>num_one_log &lt;- log(3)</code></pre>
<p>log(3) is evaluated first and then assigned to an object named <em>num_one_log</em>. Let’s create a slightly longer vector:</p>
<pre class="r white"><code>num_five &lt;- c(2, 15, -8, 0, -65)</code></pre>
<p>Now we have a vector containing five elements instead of one. Here we make use of a function, <code>c</code>, that ‘concatenates’ the objects that are fed to it as its <code>arguments</code>. A function is ‘called’ by typing its name (in this case its just <em>c</em>) followed by one or more arguments typed inside parenthesis.</p>
</div>
<div id="peeking-into-our-vector" class="section level3">
<h3>Peeking into our Vector</h3>
<p>Let’s look into what kind of vector it is:</p>
<pre class="r white"><code>str(num_five)
#&gt;  num [1:5] 2 15 -8 0 -65</code></pre>
<p><code>str</code> function gives a concise information of what kind of object we are dealing with. In this case, we have a numeric (num) object of length 5 ([1:5]). The above output is a good visual information but sometimes we want to use this output later in our work so it is good to know functions that extract type and length of the vector separately:</p>
<pre class="r white"><code>typeof(num_five)
#&gt; [1] &quot;double&quot;</code></pre>
<pre class="r white"><code>length(num_five)
#&gt; [1] 5</code></pre>
<p>Note that ‘numeric’ type is further divided into <code>double</code> and <code>integer</code>. Sometimes we want to do a <code>logical</code> test to see whether a vector is of particular type before carrying out any further computations:</p>
<pre class="r white"><code>library(purrr)
is_numeric(num_five)
#&gt; [1] TRUE</code></pre>
<p>Above we used a function <code>is_numeric</code> from <code>purrr</code> package. There are equivalent functions in the base package too but slightly less consistent.</p>
</div>
<div id="objects-as-arguments-to-functions" class="section level3">
<h3>Objects as Arguments to Functions</h3>
<p>Objects can be arguments to a function:</p>
<pre class="r white"><code>long_vec &lt;- c(num_five, num_one, num_one_log)
long_vec
#&gt; [1]   2.000000  15.000000  -8.000000   0.000000 -65.000000   3.000000
#&gt; [7]   1.098612</code></pre>
<p>Here we created a longer vector using existing vector objects as arguments to <em>c</em> function. This provides us a framework for doing more interesting work.</p>
</div>
<div id="other-ways-of-creating-a-vector" class="section level3">
<h3>Other Ways of Creating a Vector</h3>
<p>In addition to creating a vector from numbers or concatenating existing vectors, we can create sequences, repeat vectors, or pick numbers from common probability distributions:</p>
<pre class="r white"><code>seq_simple &lt;- -5:10
seq_interval &lt;- seq(from = 3, to = 50, by = 0.5)
seq_length &lt;- seq(from = 3, to = 50, length.out = 20)
rep_each &lt;- rep(num_five, each = 2)
rep_times &lt;- rep(num_five, times = 2)
norm_std &lt;- rnorm(25)
norm_unique &lt;- rnorm(25, mean = 10, sd = 5)</code></pre>
<p>First we created a simple sequence of whole numbers. Then we used <code>seq</code> function to create a sequence with arbitrary start and end points and fixed interval between the elements. After that we created another one (seq_length) with desired number of elements between arbitrary start and end points. Then using <code>rep</code> function, we created a vector by repeating each element twice and then by repeating the vector twice. In the end we created a vector (norm_std) with 25 elements from a standard normal distribution using <code>rnorm</code> and lastly created a vector with non-standard normal distribution.</p>
</div>
<div id="vector-operations" class="section level3">
<h3>Vector Operations</h3>
<p>Now that we know how to create vector objects, let’s play with these objects a bit and see what kind of operations we can perform on our vectors. We will use one of the vectors we created earlier:</p>
<pre class="r white"><code>rep_times
#&gt;  [1]   2  15  -8   0 -65   2  15  -8   0 -65</code></pre>
<p><strong>Arithmatic Operations</strong></p>
<p>We can do all kinds of math operations with our vectors. We are not going to store these in new objects but watch these <em>function calls</em> in action:</p>
<pre class="r white"><code>rep_times ^ 2
#&gt;  [1]    4  225   64    0 4225    4  225   64    0 4225</code></pre>
<pre class="r white"><code>rep_times * 1 / 5
#&gt;  [1]   0.4   3.0  -1.6   0.0 -13.0   0.4   3.0  -1.6   0.0 -13.0</code></pre>
<p>Note that the way these operations are handled is slightly different than you might think. *, ^ and other operators are <em>vectorized</em> - so first the number 2, which is a vector of length one, is <em>recycled</em> to make it the same length as the larger vector (ten in this case). Then each element of first vector is operated upon with the corresponding element of the second vector.</p>
<p>There is an interesting math operator called <em>modulo operator</em> (<code>%%</code>) - which is used to get different parts of answer of division operation. If you divide two numbers, top number is called <em>dividend</em> and bottom number is called <em>divisor</em>. The result will be a whole number (called <em>quotient</em>), and whatever fraction is left out is <em>remainder</em>.</p>
<pre class="r white"><code>rep_times %% 2      # get remainder of rep_times divided by 2.
#&gt;  [1] 0 1 0 0 1 0 1 0 0 1</code></pre>
<pre class="r white"><code>rep_times %/% 2     # get quotient of rep_times divided by 2.
#&gt;  [1]   1   7  -4   0 -33   1   7  -4   0 -33</code></pre>
<p><strong>Statistical Operations</strong></p>
<p>R will make you dizzy for the amount of statistical wizardry it packs up its sleeve. We are not going to take a deep dive, not even scratching the surface by any standards:</p>
<pre class="r white"><code>mean(rep_times)
#&gt; [1] -11.2</code></pre>
<pre class="r white"><code>sum(rep_times)
#&gt; [1] -112</code></pre>
<pre class="r white"><code>sd(rep_times)
#&gt; [1] 29.40446</code></pre>
<pre class="r white"><code>max(rep_times)
#&gt; [1] 15</code></pre>
<pre class="r white"><code>summary(rep_times)
#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#&gt;   -65.0    -8.0     0.0   -11.2     2.0    15.0</code></pre>
<p><strong>Other Interesting Operations</strong></p>
<pre class="r white"><code>sort(rep_times)
#&gt;  [1] -65 -65  -8  -8   0   0   2   2  15  15</code></pre>
<pre class="r white"><code>sort(rep_times, decreasing = TRUE)
#&gt;  [1]  15  15   2   2   0   0  -8  -8 -65 -65</code></pre>
<pre class="r white"><code>unique(rep_times)
#&gt; [1]   2  15  -8   0 -65</code></pre>
<pre class="r white"><code>rev(rep_times)
#&gt;  [1] -65   0  -8  15   2 -65   0  -8  15   2</code></pre>
</div>
<div id="chaining-of-functions" class="section level3">
<h3>Chaining of Functions</h3>
<p>The output of one function can be used as an input to another function. Say we want to find standard deviation of 50 standard normals:</p>
<pre class="r white"><code>sd(rnorm(50))
#&gt; [1] 0.7480288</code></pre>
<p>You probably want to avoid more convoluted chains as it will be confusing to read.</p>
</div>
<div id="selecting-few-elements-of-a-vector-subsetting" class="section level3">
<h3>Selecting Few Elements of a Vector (Subsetting)</h3>
<p>So far we have created vectors using a variety of functions. Now, if a vector is given to us and we are tasked with selecting certain elements from it, how do we do that. There are two useful ways to do that:</p>
<p><strong>Subsetting using position</strong></p>
<p>In R, elements of a vector are positioned (<em>indexed</em>) from 1 (many languages start at 0) to the length of the vector. Our <em>rep_times</em> vector has 10 elements, and say we want to extract first and last element, we can feed these (<em>index values</em>) as integer vector inside square brackets:</p>
<pre class="r white"><code>rep_times[c(1, length(rep_times))]
#&gt; [1]   2 -65</code></pre>
<p>If we want to select everything but the first and last element, you can put a ‘-’ sign before the vector:</p>
<pre class="r white"><code>rep_times[-c(1, length(rep_times))]
#&gt; [1]  15  -8   0 -65   2  15  -8   0</code></pre>
<p>A more powerful way of subsetting is through logical expressions.</p>
<p><strong>Subsetting using logical expressions</strong></p>
<p>Say if we had a light bulb that we could turn on if we want an element in that position and off if we don’t, it would be great. It turns out that R (and generally any programming language) has a special data type for carrying out logical operations. Let’s say we want to extract all odd numbers from our <em>rep_times</em> vector:</p>
<pre class="r white"><code>odd_filter &lt;- rep(c(TRUE, FALSE), 5)
str(odd_filter)
#&gt;  logi [1:10] TRUE FALSE TRUE FALSE TRUE FALSE ...</code></pre>
<pre class="r white"><code>is_logical(odd_filter)
#&gt; [1] TRUE</code></pre>
<pre class="r white"><code>rep_times[odd_filter]
#&gt; [1]   2  -8 -65  15   0</code></pre>
<p>Cool, but most of the times we will not create this <em>switch</em> vector manually. Instead, <code>logical expressions</code> will be used to do this job, and this will serve as a handy tool in our R toolbox. Let’s look at some logical expressions and their output:</p>
<pre class="r white"><code>rep_times &gt; 0
#&gt;  [1]  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE</code></pre>
<pre class="r white"><code>rep_times &lt; -10
#&gt;  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE</code></pre>
<pre class="r white"><code>rep_times == 0
#&gt;  [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE</code></pre>
<pre class="r white"><code>rep_times %% 2 != 0     # selecting odd numbers
#&gt;  [1] FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE</code></pre>
<p>The output of these logical expressions is either TRUE or FALSE depending on whether the logical condition is satisfied or not. Now we can feed the output of these expressions inside square brackets for subsetting our vector:</p>
<pre class="r white"><code>rep_times[rep_times &lt; -10]
#&gt; [1] -65 -65</code></pre>
<p><strong>Logical expressions can be combined using and (&amp;) and or (|) operators</strong></p>
<pre class="r white"><code>(rep_times &gt; 0) | (rep_times &lt; -10)
#&gt;  [1]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE</code></pre>
<pre class="r white"><code>(rep_times &gt; 0) &amp; (rep_times %% 2 != 0)
#&gt;  [1] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE</code></pre>
</div>
<div id="more-uses-of-logical-subsetting" class="section level3">
<h3>More Uses of Logical Subsetting</h3>
<p><strong>TRUE = 1 and FALSE = 0</strong></p>
<p>Behind the scenes, TRUE is encoded as 1 and FALSE is encoded as 0. This means we can do some neat math operations on logical vectors. Let’s say we want to know how many values are positive in my vector:</p>
<pre class="r white"><code>sum(rep_times &gt; 0)
#&gt; [1] 4</code></pre>
<p>Or say what proportion of values are non-zeros:</p>
<pre class="r white"><code>mean(rep_times != 0)
#&gt; [1] 0.8</code></pre>
<p><strong>Reassignment of some elements of a vector</strong></p>
<p>Sometimes we might need to reassign specific elements of a vector to new values. For example, let’s say, we want to replace all 0’s in our vector to -99:</p>
<pre class="r white"><code>rep_times[rep_times == 0]  &lt;- -99
rep_times
#&gt;  [1]   2  15  -8 -99 -65   2  15  -8 -99 -65</code></pre>
<p><strong>Any or all values matching a condition</strong></p>
<p>Let’s say we just want to know if any of the values in our vector are negative:</p>
<pre class="r white"><code>any(rep_times &lt; 0)
#&gt; [1] TRUE</code></pre>
<p>Or, if all of the values are non-zeros:</p>
<pre class="r white"><code>all(rep_times != 0)
#&gt; [1] TRUE</code></pre>
</div>
<div id="two-types-of-vectors" class="section level3">
<h3>Two Types of Vectors</h3>
<p>Ok, now we know two types of atomic vectors: <code>numeric</code>, one that contains numeric numbers and <code>logical</code>, that contain logical values of either <code>TRUE</code> or <code>FALSE</code>.</p>
</div>
<div id="pick-elements-randomly" class="section level3">
<h3>Pick Elements Randomly</h3>
<p>So far we have looked at subsetting of vectors where we know which element we need either by their <em>index</em> or by <em>logical subsettin</em>. Sometimes we want to randomly select some elements, and <code>sample</code> function will come to our rescue here:</p>
<pre class="r white"><code>sample(rep_times, 5)    # randomly select five elements from rep_times
#&gt; [1] -65 -65   2  -8 -99</code></pre>
<p><strong>Select certain fraction of elements</strong></p>
<pre class="r white"><code>sample(rep_times, 0.4 * length(rep_times))    # 40% of elements
#&gt; [1]   2 -65 -99 -99</code></pre>
<p><strong>A quick shortcut to shuffle integers</strong></p>
<pre class="r white"><code>sample(10)
#&gt;  [1]  4  9  6  8  1  7  5  3 10  2</code></pre>
</div>
<div id="some-special-values" class="section level3">
<h3>Some Special Values</h3>
<p>There are some special values that our two types of vectors can take, so we will discuss those here.</p>
<p><strong>NA - Not Available</strong></p>
<p>In real data, we do not always get nice clean numbers - some data points will be missing. A sensor could go bad, there could be a power failure during recording of data, a subject selected to interview is not at home etc. Before we decide what to do with these missing values, we need to understand some basic information on these values, for example how many or what proportion of the values are missing. R represents this missing data with <code>NA</code>. In reality the data exists, but we just don’t know what those values are.</p>
<p>Let’s first randomly assign some values as NA to our vector:</p>
<pre class="r white"><code>rep_times[sample(length(rep_times), 4)] &lt;- NA
rep_times
#&gt;  [1]  NA  15  -8  NA -65   2  NA  -8  NA -65</code></pre>
<p>Now to find how many or what proportion of NAs we have, we could use <code>is.na</code> function:</p>
<pre class="r white"><code>sum(is.na(rep_times))
#&gt; [1] 4</code></pre>
<pre class="r white"><code>mean(is.na(rep_times))
#&gt; [1] 0.4</code></pre>
<p>NAs are contagious:</p>
<pre class="r white"><code>sum(rep_times)
#&gt; [1] NA</code></pre>
<pre class="r white"><code>mean(rep_times)
#&gt; [1] NA</code></pre>
<p>But R provides arguments in these functions, and others, to ignore NAs while computing these statistics:</p>
<pre class="r white"><code>sum(rep_times, na.rm = TRUE)
#&gt; [1] -129</code></pre>
<pre class="r white"><code>mean(rep_times, na.rm = TRUE)
#&gt; [1] -21.5</code></pre>
<p><em>What to do with these NAs?</em></p>
<p>There are two basic treatments we can do with vectors containing NAs.</p>
<ol style="list-style-type: decimal">
<li>We can remove those observations:</li>
</ol>
<pre class="r white"><code>rep_times_na_removed &lt;- rep_times[!is.na(rep_times)]
rep_times_na_removed
#&gt; [1]  15  -8 -65   2  -8 -65</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>We can replace NAs with the mean of rest of observations:</li>
</ol>
<pre class="r white"><code>rep_times_clean &lt;- rep_times
rep_times_clean[is.na(rep_times_clean)] &lt;- mean(rep_times_clean, na.rm = TRUE)
rep_times_clean
#&gt;  [1] -21.5  15.0  -8.0 -21.5 -65.0   2.0 -21.5  -8.0 -21.5 -65.0</code></pre>
<p><strong>Inf and NaN</strong></p>
<p>Although not created intentionally, some chain of math operations in our code may lead to situations where we are dividing by 0. We want to avoid these situations since this will lead to errors and exceptions. So it is a good idea to check for these conditions on inputs before using the inputs in our functions. <code>is.infinite</code> and <code>is.nan</code> functions can be used to check these conditions:</p>
<pre class="r white"><code>undesirable &lt;- c(0, 1) / 0
undesirable
#&gt; [1] NaN Inf</code></pre>
<pre class="r white"><code>is.infinite(undesirable)
#&gt; [1] FALSE  TRUE</code></pre>
<pre class="r white"><code>is.nan(undesirable)
#&gt; [1]  TRUE FALSE</code></pre>
</div>
<div id="sequences-for-loops" class="section level3">
<h3>Sequences for Loops</h3>
<p>Sometimes we need a vector of indices of a vector so we can do iterations, loops etc. <code>seq_along</code> will be a useful function for that. This will generate an index vector 1, 2,…, length(vector).</p>
<pre class="r white"><code>seq_along(rep_times)
#&gt;  [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
</div>
<div id="creating-an-empty-vector" class="section level3">
<h3>Creating an empty vector</h3>
<p>We may want to create an empty vector sometimes. This will be useful when we want to populate the vector using loops.</p>
<pre class="r white"><code>new_num &lt;- vector(&quot;numeric&quot;, 10)
new_log &lt;- vector(&quot;logical&quot;, 10)
new_num
#&gt;  [1] 0 0 0 0 0 0 0 0 0 0</code></pre>
<pre class="r white"><code>new_log
#&gt;  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE</code></pre>
</div>
<div id="some-useful-vector-transformations" class="section level3">
<h3>Some Useful Vector Transformations</h3>
<p><strong>Recenter around mean 0</strong></p>
<pre class="r white"><code>data &lt;- sample(1:20, 10) * sample(10)
data - mean(data)
#&gt;  [1] -30.5 -34.5 -16.5   9.5 -47.5 -41.5  54.5  57.5  39.5   9.5</code></pre>
<p><strong>Recenter around mean 0 and standard deviation 1</strong></p>
<pre class="r white"><code>(data - mean(data)) / sd(data)
#&gt;  [1] -0.7628047 -0.8628446 -0.4126648  0.2375949 -1.1879745 -1.0379145
#&gt;  [7]  1.3630444  1.4380743  0.9878946  0.2375949</code></pre>
<p><strong>Rescale so all values are between 0 and 1</strong></p>
<pre class="r white"><code>(data- min(data)) / (max(data) - min(data))
#&gt;  [1] 0.16190476 0.12380952 0.29523810 0.54285714 0.00000000 0.05714286
#&gt;  [7] 0.97142857 1.00000000 0.82857143 0.54285714</code></pre>
</div>
<div id="comparing-two-vectors" class="section level3">
<h3>Comparing Two Vectors</h3>
<p>Sometimes we just want to check if two vectors are equal. <code>all.equal</code> can be a useful function for that:</p>
<pre class="r white"><code>x1 &lt;- c(1, 2, 3)
y1 &lt;- c(1, 2, 3)
y2 &lt;- c(2, 3, 4)
all.equal(x1, y1)
#&gt; [1] TRUE</code></pre>
<pre class="r white"><code>all.equal(x1, y2)
#&gt; [1] &quot;Mean relative difference: 0.5&quot;</code></pre>
</div>
<div id="third-type-of-atomic-vector" class="section level3">
<h3>Third Type of Atomic Vector</h3>
<p>The third and last type of atomic vector is <code>character</code> which is very powerful in data analysis as well as general programming. Although we have not created this type of vector so far explicitly, note that the output of some functions that we have used was a string of characters:</p>
<pre class="r white"><code>x &lt;- typeof(rep_times)
x
#&gt; [1] &quot;double&quot;</code></pre>
<pre class="r white"><code>typeof(x)
#&gt; [1] &quot;character&quot;</code></pre>
<pre class="r white"><code>is_character(x)
#&gt; [1] TRUE</code></pre>
<p>Mastering <code>Regular Expressions</code> is key to working with character data so we will learn the basics here. We are going to use <code>stringr</code> package to play with our character vectors.</p>
<pre class="r white"><code>library(stringr)</code></pre>
<p>You can create a character vector by entering anything inside quotes. We are going to use double quotes for consistency:</p>
<pre class="r white"><code>greet &lt;- &quot;hello!&quot;
greet
#&gt; [1] &quot;hello!&quot;</code></pre>
<pre class="r white"><code>typeof(greet)
#&gt; [1] &quot;character&quot;</code></pre>
<pre class="r white"><code>is_character(greet)
#&gt; [1] TRUE</code></pre>
<p>Alright, let’s create another vector and combine the two with <code>c</code> just like we did earler for numeric vectors:</p>
<pre class="r white"><code>subject &lt;- &quot;world&quot;
greetings &lt;- c(greet, subject)
greetings
#&gt; [1] &quot;hello!&quot; &quot;world&quot;</code></pre>
<pre class="r white"><code>length(greetings)
#&gt; [1] 2</code></pre>
<p>So our greetings vector contains two <em>string</em> elements. It is interesting to note that both strings can have arbitrary number of characters. Let’s say we want to know how many characters each string element has, we will use <code>str_length</code> function:</p>
<pre class="r white"><code>str_length(greetings)
#&gt; [1] 6 5</code></pre>
<p><strong>Combining elements of a vector</strong></p>
<p>If we want to combine the individual elements of a single character vector, we will use <code>str_c</code> function with <strong>collapse</strong> argument:</p>
<pre class="r white"><code>str_c(greetings, collapse = &quot;&quot;)
#&gt; [1] &quot;hello!world&quot;</code></pre>
<p><strong>Combining elements of two vectors</strong></p>
<p>If we want to combine two character vectors (element wise), we will use the same <code>str_c</code> function but with <strong>sep</strong> argument:</p>
<pre class="r white"><code>str_c(greetings, &quot;!&quot;, sep = &quot;&quot;)
#&gt; [1] &quot;hello!!&quot; &quot;world!&quot;</code></pre>
</div>
<div id="sorting-character-vectors-and-changing-case" class="section level3">
<h3>Sorting Character Vectors and Changing Case</h3>
<p>We will use data set, <code>words</code> available in <em>stringr</em> for this exercise:</p>
<pre class="r white"><code>word_sample &lt;- words[sample(length(words), 5)]
word_sample
#&gt; [1] &quot;flat&quot;   &quot;tie&quot;    &quot;indeed&quot; &quot;old&quot;    &quot;rise&quot;</code></pre>
<pre class="r white"><code>str_sort(word_sample, locale = &quot;en&quot;)
#&gt; [1] &quot;flat&quot;   &quot;indeed&quot; &quot;old&quot;    &quot;rise&quot;   &quot;tie&quot;</code></pre>
<pre class="r white"><code>str_to_lower(word_sample)
#&gt; [1] &quot;flat&quot;   &quot;tie&quot;    &quot;indeed&quot; &quot;old&quot;    &quot;rise&quot;</code></pre>
<pre class="r white"><code>str_to_upper(word_sample)
#&gt; [1] &quot;FLAT&quot;   &quot;TIE&quot;    &quot;INDEED&quot; &quot;OLD&quot;    &quot;RISE&quot;</code></pre>
<pre class="r white"><code>str_to_title(word_sample)
#&gt; [1] &quot;Flat&quot;   &quot;Tie&quot;    &quot;Indeed&quot; &quot;Old&quot;    &quot;Rise&quot;</code></pre>
</div>
<div id="pattern-matching-in-character-vectors-using-regular-expressions" class="section level3">
<h3>Pattern Matching in Character Vectors using Regular Expressions</h3>
<p>Now we are going to scratch the surface of regular expressions. Regular expressions is a subject in itself in computing world but we will cover minimum stuff just to get us started with cleaning data where needed and not worry (yet) about text analysis.</p>
<blockquote>
<p>Everything in ASCII (or Unicode) is a <em>character</em> (letters, digits, spaces, punctuations, etc.) and sequence of characters is called a <em>string</em>.</p>
</blockquote>
<p><em>stringr</em> has different functions to do different things using regular expressions but they have the same format. We will use one, <code>str_extract</code>, which extracts the matched pattern. At the end we will apply our pattern matching skills to other tools. Let’s begin by picking five random strings from <code>sentences</code> data available in <em>stringr</em>. Note that we are using <code>set.seed</code> function, this lets us repeatedly get the same set of sentences:</p>
<pre class="r white"><code>set.seed(1234)
sent_five &lt;- sentences[sample(length(sentences), 5)]
sent_five
#&gt; [1] &quot;See the cat glaring at the scared mouse.&quot;   
#&gt; [2] &quot;Drop the ashes on the worn old rug.&quot;        
#&gt; [3] &quot;The smell of burned rags itches my nose.&quot;   
#&gt; [4] &quot;He wheeled the bike past. the winding road.&quot;
#&gt; [5] &quot;Green moss grows on the northern side.&quot;</code></pre>
<p><strong>Literal match - just type what you want to match</strong></p>
<pre class="r white"><code>str_extract(sent_five, &quot;northern&quot;)
#&gt; [1] NA         NA         NA         NA         &quot;northern&quot;</code></pre>
<p><strong>Use dot (.) to match any character</strong></p>
<p>Here we introduce <em>regex</em>’s first metacharacter (something that is not matched literally but indicates some pattern). “.” will match <em>any single character</em>. Let’s say we are interested in grabbing ten characters following <em>the</em>:</p>
<pre class="r white"><code>str_extract(sent_five, &quot;the..........&quot;)
#&gt; [1] &quot;the cat glari&quot; &quot;the ashes on &quot; NA              &quot;the bike past&quot;
#&gt; [5] &quot;the northern &quot;</code></pre>
<p>It picked <em>the</em> and the following ten characters including spaces. Note that it did not pick <em>The</em> from third sentence because it starts with a capital T. If we want to disregard the case, there are multiple ways but let’s create a <em>character class</em> in this case to solve the problem.</p>
<p><strong>Use character class [ ] to match one of the characters defined in the class</strong>:</p>
<pre class="r white"><code>str_extract(sent_five, &quot;[Tt]he..........&quot;)
#&gt; [1] &quot;the cat glari&quot; &quot;the ashes on &quot; &quot;The smell of &quot; &quot;the bike past&quot;
#&gt; [5] &quot;the northern &quot;</code></pre>
<p>Now it matched either t or T followed by he followed by any ten characters. Great, now let’s say we want to pick sentences that begin with The or the. In this case, it will only be the third sentence.</p>
<ul>
<li>appending ^ to pattern inside [] will match all characters <em>excluding</em> those defined in the class.</li>
</ul>
<p><strong>^ to match the beginning of the string</strong></p>
<p>If you want to match a pattern only at the beginning of the string, you would prepend your pattern with ^:</p>
<pre class="r white"><code>str_extract(sent_five, &quot;^[Tt]he..........&quot;)
#&gt; [1] NA              NA              &quot;The smell of &quot; NA             
#&gt; [5] NA</code></pre>
<p><strong>$ to match the end of the string</strong></p>
<p>Append your pattern with $ to match it only at the end of the string:</p>
<pre class="r white"><code>str_extract(sent_five, &quot;mouse$&quot;)
#&gt; [1] NA NA NA NA NA</code></pre>
<p>Hmm..it did not match our first string that we were hoping for. Aahhh, we missed the period (.). All strings are ending with a period so we have to include that too in our pattern, but remember that period already is a metacharacter. So how do we let regex engine know that we want the literal period. Well, we append our metacharacter with an <em>escape character</em>, \. One problem here is that \ is also used in our strings and regular expressions are string arguments to our functions. We we have to escape the escape character!</p>
<blockquote>
<p>To match regex’s metacharacter literally, append it with two escape charaters: \\</p>
</blockquote>
<pre class="r white"><code>str_extract(sent_five, &quot;mouse\\.$&quot;)
#&gt; [1] &quot;mouse.&quot; NA       NA       NA       NA</code></pre>
<p><strong>Use <code>writeLines</code> to check if your regex pattern is what you expected</strong></p>
<p>Since these escape characters can cause confusion on what the regex engine is finally seeing, it is a good idea to feed our argument to <code>writeLines</code> first:</p>
<pre class="r white"><code>writeLines(&quot;mouse\\.$&quot;)
#&gt; mouse\.$</code></pre>
<p><strong>Repeating Patterns</strong></p>
<p>So far we have looked at single character matches. So if we want to match two capital letter in the following vector, we will define a character class and repeat it twice:</p>
<pre class="r white"><code>states &lt;- c(&quot;AL&quot;, &quot;MI&quot;, &quot;Hawaii&quot;, &quot;ME&quot;, &quot;Illinois&quot; )
str_extract(states, &quot;[A-Z][A-Z]&quot;)
#&gt; [1] &quot;AL&quot; &quot;MI&quot; NA   &quot;ME&quot; NA</code></pre>
<p>This can get messy quickly, say if we want to match five capital letters, or ten digits. It turns out <em>regex engine</em> has a very powerful feature of matching repetetive patterns.</p>
<ul>
<li>{n} match preceding character or group exactly <em>n</em> number of times:</li>
</ul>
<pre class="r white"><code>str_extract(states, &quot;[A-Z]{2}&quot;)
#&gt; [1] &quot;AL&quot; &quot;MI&quot; NA   &quot;ME&quot; NA</code></pre>
<ul>
<li>{m,} match the preceding character or a group m or more number of times:</li>
</ul>
<pre class="r white"><code>str_extract(sent_five, &quot;l{2,}&quot;)
#&gt; [1] NA   NA   &quot;ll&quot; NA   NA</code></pre>
<p>Similar concept applies for {,n} to match up to <em>n</em> times and {m,n} to match at least <em>m</em> times and at the most <em>n</em> times. There are shortcuts for some common repetitions:</p>
<ul>
<li>+ to match 1 or more times:</li>
</ul>
<pre class="r white"><code>money &lt;- c(&quot;$23&quot;, &quot;$ab&quot;, &quot;$4000&quot;)
str_extract(money, &quot;\\$[0-9]+&quot;)
#&gt; [1] &quot;$23&quot;   NA      &quot;$4000&quot;</code></pre>
<ul>
<li>* to match 0 to more times:</li>
</ul>
<pre class="r white"><code>str_extract(money, &quot;\\$[0-9]*&quot;)
#&gt; [1] &quot;$23&quot;   &quot;$&quot;     &quot;$4000&quot;</code></pre>
<ul>
<li>? to match 0 or 1 times:</li>
</ul>
<pre class="r white"><code>days &lt;- c(&quot;sunday&quot;, &quot;mon&quot;, &quot;tue&quot;, &quot;wednesday&quot;)
str_extract(days, &quot;((sun)|(mon)|(tue)|(wednes))(day)?&quot;)
#&gt; [1] &quot;sunday&quot;    &quot;mon&quot;       &quot;tue&quot;       &quot;wednesday&quot;</code></pre>
<p>Here we also quickly demonstrated the conecept of or, |, and groups using ()</p>
<p><strong>More character classes</strong></p>
<p>Earlier we learned a couple of examples of how to define a character class. Another example is [A-Za-z0-9] will match any letter or digit. There are shortcuts available however for commonly used classes. These when used with repetetion matches results in can result in flexible and powerful patterns:</p>
<ul>
<li>\d will match any single digit:</li>
</ul>
<pre class="r white"><code>str_extract(money, &quot;\\$\\d+&quot;)
#&gt; [1] &quot;$23&quot;   NA      &quot;$4000&quot;</code></pre>
<ul>
<li>\D will match any single non-digit</li>
</ul>
<pre class="r white"><code>address &lt;- c(&quot;abc street&quot;, &quot;NY&quot;, &quot;US&quot;, &quot;54875&quot;)
str_extract(address, &quot;\\D+&quot;)
#&gt; [1] &quot;abc street&quot; &quot;NY&quot;         &quot;US&quot;         NA</code></pre>
<ul>
<li>\w will match any alphanumeric character including _. This is equivalent to [A-Za-z0-9_]</li>
</ul>
<pre class="r white"><code>some_txt &lt;- c(&quot;$$Name..&quot;, &quot;   $Class--&quot;, &quot;$$$Address$$   &quot;)
str_extract(some_txt, &quot;\\w+&quot;)
#&gt; [1] &quot;Name&quot;    &quot;Class&quot;   &quot;Address&quot;</code></pre>
<ul>
<li>\W will match any non-alphanumeric character</li>
</ul>
<pre class="r white"><code>str_extract(some_txt , &quot;\\W+&quot;)
#&gt; [1] &quot;$$&quot;   &quot;   $&quot; &quot;$$$&quot;</code></pre>
<ul>
<li>\s will match any whitespace (space, tab, newline, carriage return)</li>
</ul>
<pre class="r white"><code>str_extract(some_txt , &quot;\\s+&quot;)
#&gt; [1] NA    &quot;   &quot; &quot;   &quot;</code></pre>
<ul>
<li>\S will match any non-whitespace</li>
</ul>
<pre class="r white"><code>str_extract(some_txt , &quot;\\S+&quot;)
#&gt; [1] &quot;$$Name..&quot;     &quot;$Class--&quot;     &quot;$$$Address$$&quot;</code></pre>
<ul>
<li>\b will match a word boundary (end of word)</li>
</ul>
<pre class="r white"><code>str_extract(sent_five, &quot;\\w+\\b&quot;)
#&gt; [1] &quot;See&quot;   &quot;Drop&quot;  &quot;The&quot;   &quot;He&quot;    &quot;Green&quot;</code></pre>
</div>
<div id="stringr-tools" class="section level3">
<h3>Stringr Tools</h3>
<p>Ok, now that we are comfortable using regular expressions, we need to put these into use with the available tools in stringr. We have already used one - <code>str_extract</code> which extracts the matched pattern. There are few others that can be very useful.</p>
<p><strong>Logical output if a match is found</strong></p>
<pre class="r white"><code>str_detect(address, &quot;\\D+&quot;)
#&gt; [1]  TRUE  TRUE  TRUE FALSE</code></pre>
<p>Note that this approach can also be used to simplify regular expressions.</p>
<p><strong>How many matches are there in the string</strong></p>
<pre class="r white"><code>str_count(sent_five, &quot;the&quot;)
#&gt; [1] 2 2 0 2 2</code></pre>
<p><strong>Replace a match with new string</strong></p>
<pre class="r white"><code>str_replace(sent_five, &quot;the&quot;, &quot;***&quot;)
#&gt; [1] &quot;See *** cat glaring at the scared mouse.&quot;   
#&gt; [2] &quot;Drop *** ashes on the worn old rug.&quot;        
#&gt; [3] &quot;The smell of burned rags itches my nose.&quot;   
#&gt; [4] &quot;He wheeled *** bike past. the winding road.&quot;
#&gt; [5] &quot;Green moss grows on *** northern side.&quot;</code></pre>
<p><strong>Split a string into pieces</strong></p>
<pre class="r white"><code>str_split(sent_five[1], &quot; &quot;)
#&gt; [[1]]
#&gt; [1] &quot;See&quot;     &quot;the&quot;     &quot;cat&quot;     &quot;glaring&quot; &quot;at&quot;      &quot;the&quot;     &quot;scared&quot; 
#&gt; [8] &quot;mouse.&quot;</code></pre>
<p>Note that this gave us a <code>list</code> object, which we have not studied yet, but you can see the function of splitting a string here.</p>
<p><strong>Not one but all matches</strong></p>
<p>All the tools that we have looked at so far will match and give you the <em>first</em> occurence in a string. All others are ignored. Above functions have equivalent <code>_all</code> commands that will apply to all matches. For example, <code>str_extract_all</code> will extract all matches. These will result in a data structure called <code>list</code>, which we have not studied yet but will look into in the future.</p>
</div>
<div id="factors---an-augmented-vector-type" class="section level3">
<h3>Factors - an Augmented Vector Type</h3>
<p>Alright, we are going to look at one more vector type, which is not an atomic vector by definition but it occurs so frequently in our data analysis that our vector discussion will be incomplete without it. It is an augmented vector because it is built on top of one of the atomic vectors - <code>integer</code>. Often times in our data, we will see variables that are <code>categorical</code> in nature, meaning they have discrete categories. For example, sex, month name, color, class etc. These type of data are modeled with <code>factor</code>. Let’s create a simple factor vector:</p>
<pre class="r white"><code>sex &lt;- c(&quot;M&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;)
sex_fac &lt;- factor(sex)
sex_fac
#&gt; [1] M M F M F
#&gt; Levels: F M</code></pre>
<pre class="r white"><code>is.factor(sex_fac)
#&gt; [1] TRUE</code></pre>
<p>R automatically assigns <code>levels</code> for the factor vector. This assignment will be alphabetical. If we don’t want that, we have to define the levels when creating the vector:</p>
<pre class="r white"><code>sort(sex_fac)
#&gt; [1] F F M M M
#&gt; Levels: F M</code></pre>
<pre class="r white"><code>sex_fac2 &lt;- factor(sex, levels = c(&quot;M&quot;, &quot;F&quot;))
sort(sex_fac2)
#&gt; [1] M M M F F
#&gt; Levels: M F</code></pre>
<p><strong>Recoding factor levels</strong></p>
<p>In the above case, the levels are apparently clear due to clear object name. Sometimes, we may want to recode to make the levels more clear. We will use <code>fct_recode</code> function from the package <code>forcats</code>:</p>
<pre class="r white"><code>library(forcats)
levels(sex_fac2)
#&gt; [1] &quot;M&quot; &quot;F&quot;</code></pre>
<pre class="r white"><code>sex_fac2 &lt;- fct_recode(sex_fac2, 
                       &quot;Male&quot; = &quot;M&quot;,
                       &quot;Female&quot; = &quot;F&quot;)
levels(sex_fac2)
#&gt; [1] &quot;Male&quot;   &quot;Female&quot;</code></pre>
<p><strong>Defining order where it matters</strong></p>
<p>Some variables will have an implied order. For example, size of a clothing line. We can define the order while creating the vector with <code>ordered = TRUE</code> argument:</p>
<pre class="r white"><code>size &lt;- factor(c(&quot;small&quot;, &quot;large&quot;, &quot;medium&quot;, &quot;small&quot;, &quot;medium&quot;),
               levels = c(&quot;small&quot;, &quot;medium&quot;, &quot;large&quot;),
               ordered = TRUE)
size[2] &gt; size[1]
#&gt; [1] TRUE</code></pre>
<p><strong>Sumamrize factors</strong></p>
<p>We can use <code>summary</code> function used earlier with numeric vectors to get concise infor about the factor vector as well:</p>
<pre class="r white"><code>summary(size)
#&gt;  small medium  large 
#&gt;      2      2      1</code></pre>
</div>
<div id="summary" class="section level3">
<h3>Summary</h3>
<p>Now we have with us the fundamental building blocks using which we can understand the existing higher level data structures as well as create some of our own! So this is really exciting. Next we will take a dive into learning some programming concepts using which we can do some more powerful things beyond the one liners that we have been using here.</p>
</div>
